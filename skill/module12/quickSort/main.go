package main

import (
	"fmt"
	"math/rand"
	"time"
)

func init() {
	rand.Seed(time.Now().UnixNano()) // необходимо для того,
	//чтобы рандом был похож на рандомный
}

func main() {
	ar := make([]int, 50)
	for i := range ar {
		ar[i] = rand.Intn(200) - 100 // ограничиваем случайно значение
		//от [-100;100]
	}

	quickSort(ar, 0, len(ar)-1)

	fmt.Println(ar)
}

// partition разбивает массив на две части и возвращает индекс опорного
// элемента
func partition(ar []int, low, high int) int {
	pivot := ar[high] // Выбираем последний элемент в качестве опорного
	i := low - 1      // Индекс меньшего элемента

	for j := low; j < high; j++ {
		if ar[j] <= pivot { // Если текущий элемент меньше или равен опорному
			i++                         // Увеличиваем индекс меньшего элемента
			ar[i], ar[j] = ar[j], ar[i] // Меняем местами
		}
	}
	// Меняем местами опорный элемент с элементом на позиции i + 1
	ar[i+1], ar[high] = ar[high], ar[i+1]
	return i + 1 // Возвращаем индекс опорного элемента
}

// quickSort рекурсивно сортирует массив
func quickSort(ar []int, low, high int) {
	if low < high {
		// Находим индекс опорного элемента
		pi := partition(ar, low, high)

		// Рекурсивно сортируем элементы до и после опорного
		quickSort(ar, low, pi-1)
		quickSort(ar, pi+1, high)
	}
}

// Объяснение кода

//     Функция partition:
//         Принимает массив arr, низкий индекс low и высокий индекс high.
//         Выбирает последний элемент массива в качестве
//опорного элемента (pivot).
//         Инициализирует индекс i, который будет отслеживать
//позицию меньшего элемента.
//         Проходит по массиву и сравнивает каждый элемент с опорным.
//Если элемент меньше или равен опорному, он перемещается влево
//(меняется местами с элементом на позиции i).
//         После завершения цикла меняет местами опорный элемент
//с элементом на позиции i + 1 и возвращает индекс опорного элемента.

//     Функция quickSort:
//         Принимает массив arr, низкий индекс low и высокий индекс high.
//         Проверяет, если low меньше high, чтобы избежать выхода
//за пределы массива.
//         Вызывает partition для получения индекса опорного элемента
//и рекурсивно сортирует элементы до и после опорного.

//     Функция main:
//         Создает пример массива arr.
//         Выводит исходный массив на экран.
//         Вызывает quickSort для сортировки массива.
//         Выводит отсортированный массив на экран.

// Примечание

// Быстрая сортировка имеет среднюю и лучшую временную сложность O(n log n),
// но в худшем случае (например, если массив уже отсортирован)
//временная сложность может достигать O(n²).
//Однако, на практике она часто работает быстрее,
//чем другие алгоритмы сортировки, благодаря меньшему
//количеству операций по сравнению с другими методами.
