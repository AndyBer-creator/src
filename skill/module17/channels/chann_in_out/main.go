// одна горутина посылает сообщения, другая принимает. Канал в данном примере позволяет выполнить
// синхронизацию общения — то есть порядок сообщений при передаче будет в точности совпадать с порядком сообщений, принимаемых из канала
package main

import (
	"fmt"
)

func getChan() <-chan int {
	// Инкапсулируем инициализацию
	// и закрытие канала внутри функции
	// Далее любая попытка закрыть канал где-то
	// в другом месте (в другой горутине)
	// приведёт к ошибке уже на стадии компиляции
	c := make(chan int)
	// Горутина-замыкание
	go func() {
		defer close(c)
		for i := 1; i <= 5; i++ {
			// Отсылаем сообщения всем желающим
			// Последовательно (упорядоченная последовательность)
			// целые числа от 1 до 5
			c <- i
		}
	}()
	return c
}

func main() {

	c := getChan()
	// Теперь принимаем сообщения
	// и выводим их в консоль
	for i := range c {
		fmt.Printf("%v \n", i)
	}
}
