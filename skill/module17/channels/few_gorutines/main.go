// пример кода, который демонстрирует решение задачи передачи сигнала о каком-то событии сразу нескольким горутинам
// (в данном примере пяти) с помощью закрытия канала
package main

import (
	"fmt"
	"sync"
	"time"
)

// Количество создаваемых горутин
const goroutineAmount int = 5

func main() {
	begin := make(chan interface{})
	var wg sync.WaitGroup
	// Цикл запуска пяти горутин
	for i := 0; i < goroutineAmount; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			<-begin
			fmt.Printf("Горутина №%d получила сигнал о закрытии и завершила свою работу\n", i)
		}(i)
	}
	fmt.Println("Оповещение и разблокировка горутин произойдёт через 5 секунд...")
	// Некий другой продолжительный по времени выполнения код,
	// вместо которого - просто блокировка на 5 секунд
	time.Sleep(time.Second * 5)
	close(begin)
	wg.Wait()
}

// В цикле запускаются пять горутин, внутри каждой происходит операция получения сообщения.
// Чтобы увеличить вероятность блокировки каждой горутины на этом этапе, мы ввели приостановку выполнения главной горутины на 5 секунд.
// По прошествии 5 секунд с большой вероятностью можно говорить, что все пять горутин заблокированы.

// Далее единственная команда закрытия канала разблокирует сразу все горутины, и каждая из них продолжит работу в соответствии со своей логикой.
//  Вот здесь и проявляется формальность, о которой мы говорили: фактически мы не занимаемся явным обменом сообщениями,
//  просто свойства каналов здесь используются формально для реализации «отслеживания события» несколькими слушателями.
//  Таким образом можно использовать каналы, когда необходимо использование условных переменных.
